/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
StereoDelay2AudioProcessor::StereoDelay2AudioProcessor()
{
	output = 0.5;
	mix = 0.5;
	delaystereo = 1;
	
	ldelay = 0.5;
	lfeedback = 0.5;
	lfilter = 0.4;

	rdelay = 0.5;
	rfeedback = 0.5;
	rfilter = 0.4;

	lpanorama = 0;
	rpanorama = 1;

	size = 44100;
	ownSampleRate = 44100;

	delayL.changeBufferSize(size);
	delayR.changeBufferSize(size);

	bypass=true;
}

StereoDelay2AudioProcessor::~StereoDelay2AudioProcessor()
{

}

//==============================================================================
const String StereoDelay2AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int StereoDelay2AudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float StereoDelay2AudioProcessor::getParameter (int index)
{
    switch (index)
	{
	case ldelayParam:			return ldelay;
	case lfeedbackParam:		return lfeedback;
	case lfilterParam:			return lfilter;
	case lpanoramaParam:		return lpanorama;

	case rdelayParam:			return rdelay;
	case rfeedbackParam:		return rfeedback;
	case rfilterParam:			return rfilter;
	case rpanoramaParam:		return rpanorama;

	case outputParam:			return output;
	case mixParam:				return mix;
	case delaystereoParam:		return delaystereo;

	default:					return 0.0f;
	}
}

void StereoDelay2AudioProcessor::setParameter (int index, float newValue)
{
	switch (index)
	{
	case ldelayParam:			ldelay = newValue; break;
	case lfeedbackParam:		lfeedback = newValue; break;
	case lfilterParam:			lfilter = newValue; break;
	case lpanoramaParam:		lpanorama = newValue; break;

	case rdelayParam:			rdelay = newValue; break;
	case rfeedbackParam:		rfeedback = newValue; break;
	case rfilterParam:			rfilter = newValue; break;
	case rpanoramaParam:		rpanorama = newValue; break;

	case outputParam:			output = newValue; break;
	case mixParam:				mix = newValue; break;
	case delaystereoParam:		delaystereo = newValue; break;

	default:					break;
	}
}

const String StereoDelay2AudioProcessor::getParameterName (int index)
{
    switch (index)
	{
	case ldelayParam:			return "ldelay";
	case lfeedbackParam:		return "lfeedback";
	case lfilterParam:			return "lfilter";
	case lpanoramaParam:		return "lpanorama";

	case rdelayParam:			return "rdelay";
	case rfeedbackParam:		return "rfeedback";
	case rfilterParam:			return "rfilter";
	case rpanoramaParam:		return "rpanorama";

	case outputParam:			return "output";
	case mixParam:				return "mix";
	case delaystereoParam:		return "delaystereo";

	default:					break;
	}
	return String::empty;
}

const String StereoDelay2AudioProcessor::getParameterText (int index)
{
    return String (getParameter (index), 2);
}

const String StereoDelay2AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String StereoDelay2AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool StereoDelay2AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool StereoDelay2AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool StereoDelay2AudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool StereoDelay2AudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int StereoDelay2AudioProcessor::getNumPrograms()
{
    return 0;
}

int StereoDelay2AudioProcessor::getCurrentProgram()
{
    return 0;
}

void StereoDelay2AudioProcessor::setCurrentProgram (int index)
{
}

const String StereoDelay2AudioProcessor::getProgramName (int index)
{
    return String::empty;
}

void StereoDelay2AudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void StereoDelay2AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    setOwnSampleRate(sampleRate);

	sr_temp_size=getOwnSampleRate();

	leftPeakFollower.resetCounter();
	rightPeakFollower.resetCounter();

	leftPeakFollower.setMaxCounter(sampleRate/20);
	rightPeakFollower.setMaxCounter(sampleRate/20);

	if(delayL.getBufferSize() < sr_temp_size)
	{
		delayL.changeBufferSize(sr_temp_size);
		

		delayR.changeBufferSize(sr_temp_size);
	}

	delayL.clearBuffer();
	delayR.clearBuffer();
}

void StereoDelay2AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void StereoDelay2AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();

	float* channelLData = buffer.getSampleData (0);
	float* channelRData = buffer.getSampleData (1);

	lowPassL.calcCeoffs(pow(1-lfilter,2)*5000,getOwnSampleRate());
	lowPassR.calcCeoffs(pow(1-rfilter,2)*5000,getOwnSampleRate());

	for (int i = 0; i < numSamples; ++i)
	{
		const float inL = channelLData[i];
		const float inR = channelRData[i];


		if (bypass==true)
		{
 			outL = (inL*(1-mix)+delayL.getSampleFromBuffer()*mix)*output*2;
			outR = (inR*(1-mix)+delayR.getSampleFromBuffer()*mix)*output*2;
		
			/*counter++;

			wait = false;

			if (abs(outL) > l_value) l_value = outL;
			if (abs(outR) > r_value) r_value = outR;

			if (counter == max_counter)
			{
				wait = true;

				l_value = 0;
				r_value = 0;
				counter = 0;
			}*/

		leftPeakFollower.sendSample(outL);
		rightPeakFollower.sendSample(outR);

        channelLData[i] = outL;
		channelRData[i] = outR;

		float mid = mSconverter.extractMiddle(inL, inR);
		float side = mSconverter.extractSide(inL, inR)*delaystereo;

		float l_mod = mSconverter.assemblyLeft(mid, side);
		float r_mod = mSconverter.assemblyRight(mid, side);

		delayL.pushSampleToBuffer(((delayL.getSampleFromBuffer()+lowPassL.filter(l_mod))*lfeedback)*(1-lpanorama) + ((delayR.getSampleFromBuffer()+lowPassR.filter(r_mod))*rfeedback)*(1-rpanorama),calcSliderToSamples(ldelay));
		delayR.pushSampleToBuffer(((delayL.getSampleFromBuffer()+lowPassL.filter(l_mod))*lfeedback)*lpanorama + ((delayR.getSampleFromBuffer()+lowPassR.filter(r_mod))*rfeedback)*rpanorama,calcSliderToSamples(rdelay));
		}
		else if(bypass==false)
		{
			channelLData[i] = inL;
			channelRData[i] = inR;

			//counter++;

			//if (abs(inL) > l_value) l_value = inL;
			//if (abs(inR) > r_value) r_value = inR;

			/*if (counter == max_counter)
			{
				l_value = 0;
				r_value = 0;
				counter = 0;

			}*/

			leftPeakFollower.sendSample(inL);
			rightPeakFollower.sendSample(inR);
		}
	}

    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
    {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
}
//==============================================================================
bool StereoDelay2AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* StereoDelay2AudioProcessor::createEditor()
{
    return new StereoDelay2AudioProcessorEditor (this);
}

//==============================================================================
void StereoDelay2AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void StereoDelay2AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

int StereoDelay2AudioProcessor::calcSliderToSamples(float value)
{
	float slider_temp = value;
	int samples = (int)(slider_temp*44100);
	return samples;
}
//==============================================================================
int StereoDelay2AudioProcessor::getOwnSampleRate()
{
	return ownSampleRate;
}
//==============================================================================
void StereoDelay2AudioProcessor::setOwnSampleRate(double value)
{
	ownSampleRate = (int)value;
}
//==============================================================================
float StereoDelay2AudioProcessor::calcSliderToTime(float value)
{
	int sr_temp = getOwnSampleRate();
	float timeValue = (float)(value*size/sr_temp);
	int milisec = (int)(timeValue*1000);
	return milisec;
}
//==============================================================================
float StereoDelay2AudioProcessor::getValueOfSampleLeft()
{
	return fabs(l_value);
}
//==============================================================================
void StereoDelay2AudioProcessor::setValueOfSampleLeft(float value)
{
	l_value = value;
}
//==============================================================================
float StereoDelay2AudioProcessor::getValueOfSampleRight()
{
	return fabs(r_value);
}
//==============================================================================
void StereoDelay2AudioProcessor::setValueOfSampleRight(float value)
{
	r_value = value;
}
//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new StereoDelay2AudioProcessor();
}
